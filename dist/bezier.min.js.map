{"version":3,"file":"bezier.min.js","sources":["../src/curve.ts","../src/spline.ts"],"sourcesContent":["import { IPoint } from './point';\r\n\r\nexport class Curve {\r\n  private static INTEGRATION_CONSTANTS = \r\n    [[-0.1252, 0.2491] , [ 0.1252, 0.2491] , [-0.3678, 0.2335],\r\n     [ 0.3678, 0.2335] , [-0.5873, 0.2032] , [ 0.5873, 0.2032],\r\n     [-0.7699, 0.1601] , [ 0.7699, 0.1601] , [-0.9041, 0.1069],\r\n     [ 0.9041, 0.1069] , [-0.9816, 0.0472] , [ 0.9816, 0.0472]];\r\n\r\n  private static base3(t : number, ps : number[]) : number {\r\n    let t1 = -3 * ps[0] + 9 * ps[1] - 9 * ps[2] + 3 * ps[3],\r\n        t2 = t * t1 + 6 * ps[0] - 12 * ps[1] + 6 * ps[2];\r\n    return t * t2 - 3 * ps[0] + 3 * ps[1];\r\n  }\r\n\r\n  private findT(target : number, guess? : number) : number {\r\n    target = Math.min(target, this.length);\r\n    guess = guess || target / this.length;\r\n\r\n    let error = (this.lengthAt(guess) - target) / this.length;\r\n\r\n    return Math.abs(error) < 0.0001 ? guess : this.findT(target, guess - error / 2);\r\n  }\r\n\r\n  private xs() : number[] {\r\n    return [this.p0.x, this.p1.x, this.p2.x, this.p3.x];\r\n  }\r\n\r\n  private ys() : number[] {\r\n    return [this.p0.y, this.p1.y, this.p2.y, this.p3.y];\r\n  }\r\n\r\n  constructor(private p0 : IPoint, \r\n              private p1 : IPoint, \r\n              private p2 : IPoint, \r\n              private p3 : IPoint) {\r\n\r\n    this.length = this.lengthAt(1);\r\n  }\r\n\r\n  startLength : number = 0;\r\n  endLength : number = 1;\r\n  segmentOffset : number = 0;\r\n  index : number = 0;\r\n  length : number;\r\n\r\n  x(t : number = 0) : number {\r\n    let omt = 1-t;\r\n    return omt * omt * omt * this.p0.x +\r\n           3 * omt * omt * t * this.p1.x +\r\n           3 * omt * t * t * this.p2.x +\r\n           t * t * t * this.p3.x;\r\n  }\r\n\r\n  y(t : number = 0) : number {\r\n    let omt = 1-t;\r\n    return omt * omt * omt * this.p0.y +\r\n           3 * omt * omt * t * this.p1.y +\r\n           3 * omt * t * t * this.p2.y +\r\n           t * t * t * this.p3.y;\r\n  }\r\n\r\n  point(t : number = 0) : IPoint {\r\n    return {\r\n      x: this.x(t),\r\n      y: this.y(t)\r\n    };\r\n  }\r\n\r\n  lengthAt(t : number = 1) : number {\r\n    t = t <= 0 ? 0 : t > 1 ? 1 : t;\r\n    let t2 = t / 2;\r\n\r\n    return Curve.INTEGRATION_CONSTANTS.map(d => {\r\n      let ct = t2 * d[0] + t2,\r\n          b3x = Curve.base3(ct, this.xs()),\r\n          b3y = Curve.base3(ct, this.ys());\r\n      return d[1] * Math.sqrt(b3x * b3x + b3y * b3y); \r\n    }).reduce((p, c) => p + c);\r\n  }\r\n\r\n  pointAtLength(z : number = 0) : IPoint {\r\n    return this.point(this.findT(z));\r\n  }\r\n\r\n  firstDerivative(t : number = 0) : IPoint {\r\n    const omt = 1 - t;\r\n    return {\r\n      x:  3 * omt * omt * (this.p1.x - this.p0.x) +\r\n          6 * omt * t * (this.p2.x - this.p1.x) +\r\n          3 * t * t * (this.p3.x - this.p2.x),\r\n      y:  3 * omt * omt * (this.p1.y - this.p0.y) +\r\n          6 * omt * t * (this.p2.y - this.p1.y) +\r\n          3 * t * t * (this.p3.y - this.p2.y)\r\n    };\r\n  }\r\n\r\n  secondDerivative(t : number = 0) : IPoint {\r\n    const omt = 1 - t;\r\n    return {\r\n      x:  6 * omt * (this.p2.x - 2 * this.p1.x + this.p0.x) +\r\n          6 * t * (this.p3.x - 2 * this.p2.x + this.p2.x),\r\n      y:  6 * omt * (this.p2.y - 2 * this.p1.y + this.p0.y) +\r\n          6 * t * (this.p3.y - 2 * this.p2.y + this.p2.y)\r\n    };\r\n  }\r\n\r\n  curvature(t : number = 0) : number {\r\n    let d1 = this.firstDerivative(t),\r\n        d2 = this.secondDerivative(t);\r\n\r\n    return (d1.x*d2.y - d1.y*d2.x) / (d1.x*d1.x + d1.y*d1.y) ** 1.5;\r\n  }\r\n\r\n  tangent(t : number = 0) : IPoint {\r\n    let d1 = this.firstDerivative(t),\r\n        d = Math.sqrt(d1.x*d1.x + d1.y*d1.y) || 1\r\n    return {\r\n      x: d1.x / d,\r\n      y: d1.y / d\r\n    };\r\n  }\r\n\r\n  normal(t: number = 0) : IPoint {\r\n    let tan = this.tangent(t);\r\n    return {\r\n      x: -tan.y, \r\n      y: tan.x\r\n    };\r\n  }\r\n\r\n  stroke() : string {\r\n    return `M ${ this.p0.x }, ${ this.p0.y }\r\n            C ${ this.p1.x }, ${ this.p1.y }\r\n              ${ this.p2.x }, ${ this.p2.y }\r\n              ${ this.p3.x }, ${ this.p3.y }`;\r\n  }\r\n\r\n  fill(width : number) : string {\r\n    let w2 = width / 2,\r\n        n0 = this.normal(0),\r\n        n3 = this.normal(1);\r\n    return `M ${ this.p0.x - n0.x*w2 }, ${ this.p0.y - n0.y*w2 }\r\n            L ${ this.p0.x + n0.x*w2 }, ${ this.p0.y + n0.y*w2 }\r\n            L ${ this.p3.x + n3.x*w2 }, ${ this.p3.y + n3.y*w2 }\r\n            L ${ this.p3.x - n3.x*w2 }, ${ this.p3.y - n3.y*w2 } Z`;\r\n  }\r\n\r\n  /**\r\n   * Creates a transform string to the point, rotated to point along the tangent of the curve.\r\n   * @param t Parametric value along the curve in the range [0, 1].\r\n   */\r\n  pointTransform(t: number = 0): string {\r\n    let p = this.point(t),\r\n        tan = this.tangent(t);\r\n    return `translate(${p.x},${p.y}) rotate(${ Math.atan2(tan.y, tan.x)*180/Math.PI})`;\r\n  }\r\n}","import { IPoint } from './point';\r\nimport { Curve } from './curve';\r\n\r\nexport class Spline {\r\n  private static ALMOST_ONE = 1 - 1e-6;\r\n\r\n  // adapted from https://www.particleincell.com/wp-content/uploads/2012/06/bezier-spline.js\r\n  // computes control points given knots K, this is the brain of the operation \r\n  private static computeControlPoints(k : number[]) : { p1: number[], p2: number[] } {\r\n    let n = k.length-1,\r\n        a = (i:number) => i <= 0 ? 0 : i >= n-1 ? 2 : 1,\r\n        b = new Array(n),\r\n        c = (i:number) => i >= n-1 ? 0 : 1,\r\n        p1 = new Array(n-1),\r\n        p2 = new Array(n-1);\r\n\r\n    b.fill(4);\r\n    b[0] = 2;\r\n    b[n-1] = 7;\r\n\r\n    let r = k.slice(0, n)\r\n             .map((v, i) => v + 2*k[i+1]);\r\n    r.push(8*k[n-1] + k[n]);\r\n\r\n    for (let i = 0; i < b.length-1; i++) {\r\n      let m = a(i+1) / b[i];\r\n      b[i+1] -= m * c(i);\r\n      r[i+1] -= m * r[i];\r\n    }\r\n\r\n    p1[n-1] = r[n-1] / b[n-1];\r\n\r\n    for (let i = b.length-2; i > 0; i--) {\r\n      p2[i] = 2 * k[i+1] - p1[i+1];\r\n    }\r\n\r\n    p2[n-1] = 0.5 * (k[n] + p1[n-1]);\r\n\r\n    return {\r\n      p1 : p1,\r\n      p2 : p2\r\n    };\r\n  }\r\n\r\n  // TODO: Probably should extract into a Math Extensions class.\r\n  private static mod = (n : number, m : number) => ((n % m) + m) % m;\r\n\r\n  private static extendClosedSpline<T>(xs : T[]) : T[] {\r\n    let left = [],\r\n        right = [];\r\n\r\n    for (let i = 0; i < 12; i++) {\r\n      left.push(xs[Spline.mod(xs.length-i-1, xs.length)]);\r\n    }\r\n\r\n    for (let i = 0; i < 12; i++) {\r\n      right.push(xs[i % xs.length]);\r\n    }\r\n\r\n    return left.concat(xs).concat(right);\r\n  }\r\n\r\n  private static sliceClosedSpline<T>(xs : T[]) : T[] {\r\n    return xs.slice(12, xs.length-24);\r\n  }\r\n\r\n  private static computeSpline(xs : number[], ys : number[], closed : boolean = false) : Curve[] {\r\n    if (closed) {\r\n      xs = Spline.extendClosedSpline(xs);\r\n      ys = Spline.extendClosedSpline(ys);\r\n    }\r\n\r\n    let cx = Spline.computeControlPoints(xs),\r\n        cy = Spline.computeControlPoints(ys),\r\n        startLength = 0,\r\n        result = [];\r\n\r\n    if (closed) {\r\n      xs = Spline.sliceClosedSpline(xs);\r\n      ys = Spline.sliceClosedSpline(ys);\r\n      cx.p1 = Spline.sliceClosedSpline(cx.p1);\r\n      cx.p2 = Spline.sliceClosedSpline(cx.p2);\r\n      cy.p1 = Spline.sliceClosedSpline(cy.p1);\r\n      cy.p2 = Spline.sliceClosedSpline(cy.p2);\r\n    }\r\n\r\n    for (let i = 0; i < xs.length-1; i++) {\r\n      let c = new Curve(\r\n                { x: xs[i],    y: ys[i]    },\r\n                { x: cx.p1[i], y: cy.p1[i] },\r\n                { x: cx.p2[i], y: cy.p2[i] },\r\n                { x: xs[i+1],  y: ys[i+1]  });\r\n\r\n      c.startLength = startLength;\r\n      c.endLength = startLength + c.length;\r\n      c.segmentOffset = i / (xs.length-1);\r\n      c.index = i;\r\n\r\n      startLength += c.length;\r\n\r\n      result.push(c);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private marshalCurve<T>(func : (t : number) => T) : (t : number) => T {\r\n    return t => {\r\n      t = (t < 0 ? 0 : t > Spline.ALMOST_ONE ? Spline.ALMOST_ONE : t) * this.curves.length || 0;\r\n      let index = Math.trunc(t);\r\n      return func.call(this.curves[index], t - index);\r\n    };\r\n  }\r\n\r\n  private static findCurveIndex(lengths : number[], z : number, start : number, stop : number) : number {\r\n    let mid = (start + stop) >> 1;\r\n\r\n    if ((lengths[mid-1] || 0) <= z && z <= lengths[mid]) {\r\n      return mid;\r\n    }\r\n\r\n    if (z < (lengths[mid-1] || 0)) {\r\n      return Spline.findCurveIndex(lengths, z, start, mid);\r\n    }\r\n\r\n    return Spline.findCurveIndex(lengths, z, mid+1, stop);\r\n  }\r\n\r\n  constructor(public knots : IPoint[], public closed : boolean = false) { \r\n    this.curves = Spline.computeSpline(knots.map(p => p.x),\r\n                                       knots.map(p => p.y),\r\n                                       closed);\r\n\r\n    this.length = this.curves[this.curves.length-1].endLength;\r\n    this.endT = this.curves.length;\r\n  }\r\n\r\n  /**\r\n   * The value of t that goes to the end of the Spline.\r\n   */\r\n  endT : number;\r\n\r\n  /**\r\n   * List of [[Curve]]s that make up the Spline.\r\n   */\r\n  curves : Curve[];\r\n\r\n  /**\r\n   * Total length of the Spline.\r\n   */\r\n  length : number;\r\n\r\n  /**\r\n   * Get the x coordinate given t in the range [0, endT].\r\n   */\r\n  x : (t:number) => number = this.marshalCurve(Curve.prototype.x);\r\n\r\n  /**\r\n   * Get the y coordinate given t in the range [0, endT].\r\n   */\r\n  y : (t:number) => number = this.marshalCurve(Curve.prototype.y);\r\n\r\n  /**\r\n   * Get the [[IPoint]] given t in the range [0, endT].\r\n   */\r\n  point : (t:number) => IPoint = this.marshalCurve(Curve.prototype.point);\r\n\r\n  /**\r\n   * Get the component-wise first derivative at the given t in the range [0, endT].\r\n   * Returns as an [[IPoint]] representing the derivatives with respect to x and y.\r\n   */\r\n  firstDerivative : (t:number) => IPoint = this.marshalCurve(Curve.prototype.firstDerivative);\r\n\r\n  /**\r\n   * Get the component-wise second derivative at the given t in the range [0, endT].\r\n   * Returns as an [[IPoint]] representing the 2nd derivatives with respect to x and y.\r\n   */\r\n  secondDerivative : (t:number) => IPoint = this.marshalCurve(Curve.prototype.secondDerivative);\r\n\r\n  /**\r\n   * Get the curvature at the given t in the range [0, endT].\r\n   * Curvature is the inverse of the instantaneous radius.\r\n   * Note: for a straight line, curvature will return either Infinity or -Infinity.\r\n   */\r\n  curvature : (t:number) => number = this.marshalCurve(Curve.prototype.curvature);\r\n\r\n  /**\r\n   * Get the tangent at the given t in the range [0, endT]. The direction will be in the\r\n   * increasing-t direction.\r\n   * Returns as an [[IPoint]] representing the unit vector direction of the tangent.\r\n   */\r\n  tangent : (t:number) => IPoint = this.marshalCurve(Curve.prototype.tangent);\r\n\r\n  /**\r\n   * Get the normal at the given t in the range [0, endT]. The direction points to the left\r\n   * with respect to the tangent direction.\r\n   * Returns as an [[IPoint]] respresenting the unit vector direction of the normal.\r\n   */\r\n  normal : (t:number) => IPoint = this.marshalCurve(Curve.prototype.normal);\r\n\r\n  /**\r\n   * Get the transform string at the given t in the range [0, endT]. This will result in an SVG/CSS\r\n   * transform that translates to the resulting point and is rotated along the direction of the\r\n   * tangent. This is analogous to a particle traveling along the spline at position t.\r\n   */\r\n  pointTransform : (t:number) => string = this.marshalCurve(Curve.prototype.pointTransform);\r\n\r\n  /**\r\n   * Get the point along the Spline at length z. Note that this operation is much more expensive\r\n   * than the others that take the 't' parameter. If using this frequently, consider [[normalize]]ing\r\n   * the Spline and using the [[point]] function.\r\n   * Returns the [[IPoint]] representing the coordinates of the Spline at the given length.\r\n   * @param z The length along the Spline to find.\r\n   */\r\n  pointAtLength(z : number = 0) : IPoint {\r\n    let i = Spline.findCurveIndex(this.curves.map(c => c.endLength), z, 0, this.curves.length);\r\n    return this.curves[i].pointAtLength(z - this.curves[i].startLength);\r\n  }\r\n\r\n  /**\r\n   * Computes a new [[Spline]] with the knots (end points of the individual curves) evenly spaced\r\n   * along the Spline. The result will be a Spline with the same shape, but with each curve approximately\r\n   * [[curveLength]] long or contain exactly [[curveCount]] [[Curve]]s.\r\n   * \r\n   * Note: This is a fairly expensive operation because it computes lengths along the Spline. However, the\r\n   * resulting Spline will have t values that are approximately proportional to length along the curve\r\n   * (scaled by the curveLength parameter), making such calculations much more efficient going forward.\r\n   * \r\n   * @param curveLength Default 1. The desired length of all [[Curve]]s in the Spline.\r\n   * @param curveCount Defaults to the Spline [[length]] / curveLength. If curveLength is specified, this\r\n   * parameter is ignored.\r\n   * \r\n   * @example\r\n   * let s1 = new Spline([{ x:0, y:0 }, { x:1, y:0 }, { x:30, y:0 }]); // non-uniform linear spline.\r\n   * console.log(s1.x(0), s1.x(1), s1.x(2)); // 0, 1, 30\r\n   * \r\n   * let s2 = s1.normalize(3); // s2's t-values increase by 1 for every 3 units along its length.\r\n   * console.log(s2.x(0), s2.x(1), s1.x(2)); // 0, 3, 6\r\n   */\r\n  normalize(curveLength ?: number, curveCount ?: number) : Spline {\r\n    curveLength = curveLength || this.length / curveCount! || 1;\r\n    curveCount = Math.ceil(this.length / curveLength);\r\n\r\n    return new Spline(Array(curveCount).map((_, i) => this.pointAtLength(i * curveLength!)), this.closed);\r\n  }\r\n\r\n  /**\r\n   * Creates a path string that draws the Spline. \r\n   */\r\n  stroke() : string {\r\n    return this.curves.map(c => c.stroke()).join(' ');\r\n  }\r\n\r\n  /**\r\n   * Creates a path string that draws filled rectangles along the path.\r\n   * @param width \r\n   */\r\n  fill(width : number) : string {\r\n    return this.curves.map(c => c.fill(width)).join(' ');\r\n  }\r\n}"],"names":["p0","p1","p2","p3","this","length","lengthAt","Curve","t","ps","target","guess","Math","min","error","abs","findT","x","y","omt","t2","INTEGRATION_CONSTANTS","map","d","ct","b3x","base3","_this","xs","b3y","ys","sqrt","reduce","p","c","z","point","d1","firstDerivative","d2","secondDerivative","tan","tangent","width","w2","n0","normal","n3","atan2","PI","knots","closed","marshalCurve","prototype","curvature","pointTransform","curves","Spline","computeSpline","endLength","endT","k","n","a","i","b","Array","fill","r","slice","v","push","m","left","right","mod","concat","extendClosedSpline","cx","computeControlPoints","cy","startLength","result","sliceClosedSpline","segmentOffset","index","func","ALMOST_ONE","trunc","call","lengths","start","stop","mid","findCurveIndex","pointAtLength","curveLength","curveCount","ceil","_","stroke","join"],"mappings":"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"}