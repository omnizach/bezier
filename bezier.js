// Generated by CoffeeScript 1.10.0

/*

 * Bezier
A library for generating smooth Bezier curves and splines. This
contains extra functionality missing from SVG.

## Credits

* Function to create control points of a Bezier Spline:
  [particleincell.com](https://www.particleincell.com)
* Function to compute the length of a Bezier Curve:
  [raphael](https://github.com/DmitryBaranovskiy/raphael)

## License
[MIT](http://en.wikipedia.org/wiki/MIT_License)
 */

(function() {
  var ALMOST_ONE, Curve, Point, Spline, _zip, interpolateTransform, interpolateX, interpolateY,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    slice = [].slice;

  _zip = function() {
    var arr, i, j, length, lengthArray, ref, results;
    lengthArray = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = arguments.length; j < len; j++) {
        arr = arguments[j];
        results.push(arr.length);
      }
      return results;
    }).apply(this, arguments);
    length = Math.min.apply(Math, lengthArray);
    results = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = arguments.length; l < len; l++) {
          arr = arguments[l];
          results1.push(arr[i]);
        }
        return results1;
      }).apply(this, arguments));
    }
    return results;
  };

  Function.prototype._getter = function(prop, get) {
    return Object.defineProperty(this.prototype, prop, {
      get: get,
      configurable: true
    });
  };

  ALMOST_ONE = 1 - 1e-6;

  Point = (function() {
    function Point(x, y) {
      if (!(this instanceof Point)) {
        return new Point(x, y);
      }
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Curve = (function() {
    Curve.penPath = function(c) {
      return "M " + c.p0.x + ", " + c.p0.y + " C " + c.p1.x + ", " + c.p1.y + " " + c.p2.x + ", " + c.p2.y + " " + c.p3.x + ", " + c.p3.y;
    };

    Curve.paintPath = function(w) {
      var w2;
      w2 = w / 2;
      return function(c) {
        var n0, n3;
        n0 = c.normal(0);
        n3 = c.normal(1);
        return "M " + (c.p0.x - n0.x * w2) + ", " + (c.p0.y - n0.y * w2) + " L " + (c.p0.x + n0.x * w2) + ", " + (c.p0.y + n0.y * w2) + " L " + (c.p3.x + n3.x * w2) + ", " + (c.p3.y + n3.y * w2) + " L " + (c.p3.x - n3.x * w2) + ", " + (c.p3.y - n3.y * w2) + " Z";
      };
    };

    function Curve(p0, p1, p2, p3) {
      if (!(this instanceof Curve)) {
        return new Curve(p0, p1, p2, p3);
      }
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
    }

    Curve.prototype._findT = function(target, guess) {
      var error;
      target = Math.min(target, this.length);
      guess = guess || target / this.length;
      error = (this.lengthAt(guess) - target) / this.length;
      if (Math.abs(error) < 0.0001) {
        return guess;
      } else {
        return this._findT(target, guess - error / 2);
      }
    };

    Curve._base3 = function(t, p1, p2, p3, p4) {
      var t1, t2;
      t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
      return t * t2 - 3 * p1 + 3 * p2;
    };

    Curve.prototype.lengthAt = function(t) {
      var integrate, t2;
      if (t == null) {
        t = 1;
      }
      t = t > 1 ? 1 : t < 0 ? 0 : t;
      t2 = t / 2;
      integrate = function(d) {
        var ct;
        ct = t2 * d[0] + t2;
        return d[1] * Math.sqrt(Math.pow(Curve._base3(ct, this.p0.x, this.p1.x, this.p2.x, this.p3.x), 2) + Math.pow(Curve._base3(ct, this.p0.y, this.p1.y, this.p2.y, this.p3.y), 2));
      };
      return t2 * [[-0.1252, 0.2491], [0.1252, 0.2491], [-0.3678, 0.2335], [0.3678, 0.2335], [-0.5873, 0.2032], [0.5873, 0.2032], [-0.7699, 0.1601], [0.7699, 0.1601], [-0.9041, 0.1069], [0.9041, 0.1069], [-0.9816, 0.0472], [0.9816, 0.0472]].map(integrate, this).reduce(function(p, c) {
        return p + c;
      });
    };

    Curve._getter('length', function() {
      return this._length != null ? this._length : this._length = this.lengthAt(1);
    });

    Curve.prototype.x = function(t) {
      if (t == null) {
        t = 0;
      }
      return Math.pow(1 - t, 3) * this.p0.x + 3 * Math.pow(1 - t, 2) * t * this.p1.x + 3 * (1 - t) * Math.pow(t, 2) * this.p2.x + Math.pow(t, 3) * this.p3.x;
    };

    Curve.prototype.y = function(t) {
      if (t == null) {
        t = 0;
      }
      return Math.pow(1 - t, 3) * this.p0.y + 3 * Math.pow(1 - t, 2) * t * this.p1.y + 3 * (1 - t) * Math.pow(t, 2) * this.p2.y + Math.pow(t, 3) * this.p3.y;
    };

    Curve.prototype.point = function(t) {
      if (t == null) {
        t = 0;
      }
      return Point(this.x(t), this.y(t));
    };

    Curve.prototype.pointAtLength = function(z) {
      if (z == null) {
        z = 0;
      }
      return this.point(this._findT(z));
    };

    Curve.prototype.firstDerivative = function(t) {
      if (t == null) {
        t = 0;
      }
      return new Point(3 * Math.pow(1 - t, 2) * (this.p1.x - this.p0.x) + 6 * (1 - t) * t * (this.p2.x - this.p1.x) + 3 * Math.pow(t, 2) * (this.p3.x - this.p2.x), 3 * Math.pow(1 - t, 2) * (this.p1.y - this.p0.y) + 6 * (1 - t) * t * (this.p2.y - this.p1.y) + 3 * Math.pow(t, 2) * (this.p3.y - this.p2.y));
    };

    Curve.prototype.secondDerivative = function(t) {
      if (t == null) {
        t = 0;
      }
      return new Point(6 * (1 - t) * (this.p2.x - 2 * this.p1.x + this.p0.x) + 6 * t * (this.p3.x - 2 * this.p2.x + this.p2.x), 6 * (1 - t) * (this.p2.y - 2 * this.p1.y + this.p0.y) + 6 * t * (this.p3.y - 2 * this.p2.y + this.p2.y));
    };

    Curve.prototype.curvature = function(t) {
      var d1, d2;
      if (t == null) {
        t = 0;
      }
      d1 = this.firstDerivative(t) || 0;
      d2 = this.secondDerivative(t) || 0;
      return (d1.x * d2.y - d1.y * d2.x) / Math.pow(Math.pow(d1.x, 2) + Math.pow(d1.y, 2), 1.5);
    };

    Curve.prototype.tangent = function(t) {
      var d, d1;
      if (t == null) {
        t = 0;
      }
      d1 = this.firstDerivative(t);
      d = Math.sqrt(d1.x * d1.x + d1.y * d1.y) || 1;
      return new Point(d1.x / d, d1.y / d);
    };

    Curve.prototype.normal = function(t) {
      var tan;
      if (t == null) {
        t = 0;
      }
      tan = this.tangent(t);
      return new Point(-tan.y, tan.x);
    };

    Curve.prototype.pointTransform = function(t) {
      var ref, tan, x, y;
      if (t == null) {
        t = 0;
      }
      ref = [this.x(t), this.y(t)], x = ref[0], y = ref[1];
      tan = this.tangent(t);
      return "translate(" + x + ", " + y + ") rotate(" + (Math.atan2(tan.y, tan.x) * 180 / Math.PI) + ")";
    };

    return Curve;

  })();

  Spline = (function() {
    Spline.computeControlPoints = function(k) {
      var a, b, c, i, j, l, m, n, o, p1, p2, r, ref, ref1, ref2;
      a = function(i) {
        if (i <= 0) {
          return 0;
        } else if (i >= n - 1) {
          return 2;
        } else {
          return 1;
        }
      };
      c = function(i) {
        if (i >= n - 1) {
          return 0;
        } else {
          return 1;
        }
      };
      n = k.length - 1;
      p1 = new Array(n - 1);
      p2 = new Array(n - 1);
      b = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(4);
        }
        return results;
      })();
      b[0] = 2;
      b[n - 1] = 7;
      r = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = n - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(4 * k[i] + 2 * k[i + 1]);
        }
        return results;
      })();
      r[0] = k[0] + 2 * k[1];
      r.push(8 * k[n - 1] + k[n]);
      for (i = j = 0, ref = b.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        m = a(i + 1) / b[i];
        b[i + 1] -= m * c(i);
        r[i + 1] -= m * r[i];
      }
      p1[n - 1] = r[n - 1] / b[n - 1];
      for (i = l = ref1 = b.length - 2; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {
        p1[i] = (r[i] - c(i) * p1[i + 1]) / b[i];
      }
      for (i = o = 0, ref2 = b.length - 1; 0 <= ref2 ? o < ref2 : o > ref2; i = 0 <= ref2 ? ++o : --o) {
        p2[i] = 2 * k[i + 1] - p1[i + 1];
      }
      p2[n - 1] = 0.5 * (k[n] + p1[n - 1]);
      return {
        p1: p1,
        p2: p2
      };
    };

    Spline.computeSpline = function(xs, ys, closed) {
      var c, cx, cy, extend, extendLeft, extendRight, i, j, len, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, ref, ref1, results, startLength;
      extend = 12;
      if (closed) {
        extendRight = function(ns) {
          var i, j, ref, results;
          results = [];
          for (i = j = 0, ref = extend; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(ns[modulo(i, ns.length)]);
          }
          return results;
        };
        extendLeft = function(ns) {
          var i, j, ref, results;
          results = [];
          for (i = j = ref = extend; ref <= 0 ? j < 0 : j > 0; i = ref <= 0 ? ++j : --j) {
            results.push(ns[modulo(ns.length - i, ns.length)]);
          }
          return results;
        };
        xs = slice.call(extendLeft(xs)).concat(slice.call(xs), slice.call(extendRight(xs)));
        ys = slice.call(extendLeft(ys)).concat(slice.call(ys), slice.call(extendRight(ys)));
      }
      cx = Spline.computeControlPoints(xs);
      cy = Spline.computeControlPoints(ys);
      startLength = 0;
      if (closed) {
        xs = xs.slice(extend, +(-extend) + 1 || 9e9);
        ys = ys.slice(extend, +(-extend) + 1 || 9e9);
        cx.p1 = cx.p1.slice(extend, +(-extend) + 1 || 9e9);
        cy.p1 = cy.p1.slice(extend, +(-extend) + 1 || 9e9);
        cx.p2 = cx.p2.slice(extend, +(-extend) + 1 || 9e9);
        cy.p2 = cy.p2.slice(extend, +(-extend) + 1 || 9e9);
      }
      ref = _zip(xs.slice(0, -1), ys.slice(0, -1), cx.p1, cy.p1, cx.p2, cy.p2, xs.slice(1), ys.slice(1));
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        ref1 = ref[i], p0x = ref1[0], p0y = ref1[1], p1x = ref1[2], p1y = ref1[3], p2x = ref1[4], p2y = ref1[5], p3x = ref1[6], p3y = ref1[7];
        c = new Curve(new Point(p0x, p0y), new Point(p1x, p1y), new Point(p2x, p2y), new Point(p3x, p3y));
        c.startLength = startLength;
        c.endLength = startLength + c.length;
        c.segmentOffset = i / (xs.length - 1);
        c.index = i;
        startLength += c.length;
        results.push(c);
      }
      return results;
    };

    function Spline(knots, closed) {
      var c;
      if (closed == null) {
        closed = false;
      }
      if (!(this instanceof Spline)) {
        return new Spline(knots, closed);
      }
      this.closed = closed;
      this.curves = Spline.computeSpline(knots.map(function(p) {
        return p.x;
      }), knots.map(function(p) {
        return p.y;
      }), closed);
      this.startLengths = (function() {
        var j, len, ref, results;
        ref = this.curves;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.startLength);
        }
        return results;
      }).call(this);
      this.endLengths = (function() {
        var j, len, ref, results;
        ref = this.curves;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.endLength);
        }
        return results;
      }).call(this);
      this.length = this.endLengths.slice(-1)[0];
    }

    Spline._marshalCurve = function(funcName) {
      return function(t) {
        var index;
        t = (t < 0 ? 0 : t > ALMOST_ONE ? ALMOST_ONE : t) * this.curves.length || 0;
        index = Math.trunc(t);
        return this.curves[index][funcName](t - index);
      };
    };

    Spline.prototype.x = Spline._marshalCurve('x');

    Spline.prototype.y = Spline._marshalCurve('y');

    Spline.prototype.point = Spline._marshalCurve('point');

    Spline.prototype.pointAtLength = function(z) {
      var findCurveIndex, i;
      if (z == null) {
        z = 0;
      }
      findCurveIndex = function(lengths, z, start, stop) {
        var mid;
        mid = start + stop >>> 1;
        switch (false) {
          case !(((lengths[mid - 1] || 0) <= z && z <= lengths[mid])):
            return mid;
          case !(z < (lengths[mid - 1] || 0)):
            return findCurveIndex(lengths, z, start, mid);
          default:
            return findCurveIndex(lengths, z, mid + 1, stop);
        }
      };
      i = findCurveIndex(this.endLengths, Math.min(z, this.endLengths[this.endLengths.length - 1]), 0, this.endLengths.length);
      return this.curves[i].pointAtLength(z - this.startLengths[i]);
    };

    Spline.prototype.firstDerivative = Spline._marshalCurve('firstDerivative');

    Spline.prototype.secondDerivative = Spline._marshalCurve('secondDerivative');

    Spline.prototype.curvature = Spline._marshalCurve('curvature');

    Spline.prototype.tangent = Spline._marshalCurve('tangent');

    Spline.prototype.normal = Spline._marshalCurve('normal');

    Spline.prototype.pointTransform = Spline._marshalCurve('pointTransform');

    Spline.prototype.normalize = function(segmentLength, segmentCount) {
      var i, ps;
      if (segmentLength == null) {
        segmentLength = this.length / segmentCount || 1;
      }
      if (segmentCount == null) {
        segmentCount = Math.ceil(this.length / segmentLength);
      }
      ps = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = segmentCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(this.pointAtLength(i * segmentLength));
        }
        return results;
      }).call(this);
      return Spline(ps, this.closed);
    };

    return Spline;

  })();

  interpolateX = function(spline) {
    return spline.x.bind(spline);
  };

  interpolateY = function(spline) {
    return spline.y.bind(spline);
  };

  interpolateTransform = function(spline) {
    return spline.pointTransform.bind(spline);
  };

  this.bezier = {
    Point: Point,
    Curve: Curve,
    Spline: Spline,
    interpolateX: interpolateX,
    interpolateY: interpolateY,
    interpolateTransform: interpolateTransform
  };

}).call(this);

//# sourceMappingURL=bezier.js.map
