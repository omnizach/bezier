// Generated by CoffeeScript 1.10.0

/*

 * Bezier
A library for generating smooth Bezier curves and splines. This contains extra functionality missing from SVG.

## Credits

* Function to create control points of a Bezier Spline: [particleincell.com](https://www.particleincell.com)
* Function to compute the length of a Bezier Curve: [raphael](https://github.com/DmitryBaranovskiy/raphael)

## License
[MIT](http://en.wikipedia.org/wiki/MIT_License)
 */

(function() {
  var BezierCurve, BezierSpline, Point, _zip,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    slice = [].slice;

  _zip = function() {

    /* Utility function for array zip. */
    var arr, i, j, length, lengthArray, ref, results;
    lengthArray = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = arguments.length; j < len; j++) {
        arr = arguments[j];
        results.push(arr.length);
      }
      return results;
    }).apply(this, arguments);
    length = Math.min.apply(Math, lengthArray);
    results = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = arguments.length; l < len; l++) {
          arr = arguments[l];
          results1.push(arr[i]);
        }
        return results1;
      }).apply(this, arguments));
    }
    return results;
  };

  Function.prototype._getter = function(prop, get) {

    /* Utility function for defining object property getter. */
    return Object.defineProperty(this.prototype, prop, {
      get: get,
      configurable: true
    });
  };

  Function.prototype._setter = function(prop, set) {

    /* Utility function for defining object property setter. */
    return Object.defineProperty(this.prototype, prop, {
      set: set,
      configurable: true
    });
  };

  Point = (function() {

    /* A Point object represents a location in space or a vector. */
    function Point(x, y) {
      this.x = x;
      this.y = y;

      /*
      * x: Number. The x coordinate
      * y: Number. The y coordinate
      
      ```
      var p = new Point(35, 27); // { x: 35, y: 27 }
      ```
       */
    }

    return Point;

  })();

  BezierCurve = (function() {

    /*
    A BezierCurve represents one segment of a spline.
     */
    BezierCurve._base3 = function(t, p1, p2, p3, p4) {
      var t1, t2;
      t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
      return t * t2 - 3 * p1 + 3 * p2;
    };

    function BezierCurve(p0, p11, p21, p31) {
      this.p0 = p0;
      this.p1 = p11;
      this.p2 = p21;
      this.p3 = p31;

      /*
      * p0: Point. start point
      * p1: Point. control point 1
      * p2: Point. control point 2
      * p3: Point. end point
       */
    }

    BezierCurve.prototype._findT = function(target, guess) {
      var error;
      target = Math.min(target, this.length);
      guess = guess || target / this.length;
      error = (this.lengthAt(guess) - target) / this.length;
      if (Math.abs(error) < 0.0001) {
        return guess;
      } else {
        return this._findT(target, guess - error / 2);
      }
    };

    BezierCurve.prototype.lengthAt = function(t) {
      var integrate, t2;
      if (t == null) {
        t = 1;
      }

      /*
      Computes the length at position t of the curve.
      
      * t: Number. The portion of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns number, the length value.
       */
      t = t > 1 ? 1 : t < 0 ? 0 : t;
      t2 = t / 2;
      integrate = function(d) {
        var ct;
        ct = t2 * d[0] + t2;
        return d[1] * Math.sqrt(Math.pow(BezierCurve._base3(ct, this.p0.x, this.p1.x, this.p2.x, this.p3.x), 2) + Math.pow(BezierCurve._base3(ct, this.p0.y, this.p1.y, this.p2.y, this.p3.y), 2));
      };
      return t2 * [[-0.1252, 0.2491], [0.1252, 0.2491], [-0.3678, 0.2335], [0.3678, 0.2335], [-0.5873, 0.2032], [0.5873, 0.2032], [-0.7699, 0.1601], [0.7699, 0.1601], [-0.9041, 0.1069], [0.9041, 0.1069], [-0.9816, 0.0472], [0.9816, 0.0472]].map(integrate, this).reduce(function(p, c) {
        return p + c;
      });
    };

    BezierCurve._getter('length', function() {
      return this._length != null ? this._length : this._length = this.lengthAt(1);
    });


    /*
    The full length of the curve
     */

    BezierCurve.prototype.point = function(t) {

      /*
      Computes the point at position t of the curve.
      
      * t: number. The portion of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: Point, the location point.
       */
      return new Point(Math.pow(1 - t, 3) * this.p0.x + 3 * Math.pow(1 - t, 2) * t * this.p1.x + 3 * (1 - t) * Math.pow(t, 2) * this.p2.x + Math.pow(t, 3) * this.p3.x, Math.pow(1 - t, 3) * this.p0.y + 3 * Math.pow(1 - t, 2) * t * this.p1.y + 3 * (1 - t) * Math.pow(t, 2) * this.p2.y + Math.pow(t, 3) * this.p3.y);
    };

    BezierCurve.prototype.pointAtLength = function(z) {

      /*
      Computes the point at a length of the curve.
      
      * z: number. The length of the curve to travel.
      * Returns: {Point} the location point.
       */
      return this.point(this._findT(z));
    };

    BezierCurve.prototype.firstDerivative = function(t) {

      /*
      Computes the first derivative at position t of the curve.
      
      * t: number. The point of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: Point, The derivative as a vector.
       */
      return new Point(3 * Math.pow(1 - t, 2) * (this.p1.x - this.p0.x) + 6 * (1 - t) * t * (this.p2.x - this.p1.x) + 3 * Math.pow(t, 2) * (this.p3.x - this.p2.x), 3 * Math.pow(1 - t, 2) * (this.p1.y - this.p0.y) + 6 * (1 - t) * t * (this.p2.y - this.p1.y) + 3 * Math.pow(t, 2) * (this.p3.y - this.p2.y));
    };

    BezierCurve.prototype.secondDerivative = function(t) {

      /*
      Computes the second derivative at position t of the curve.
      
      * t: number. The point of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: Point. The second derivative as a vector.
       */
      return new Point(6 * (1 - t) * (this.p2.x - 2 * this.p1.x + this.p0.x) + 6 * t * (this.p3.x - 2 * this.p2.x + this.p2.x), 6 * (1 - t) * (this.p2.y - 2 * this.p1.y + this.p0.y) + 6 * t * (this.p3.y - 2 * this.p2.y + this.p2.y));
    };

    BezierCurve.prototype.curvature = function(t) {

      /*
      Computes the curvature at position t of the curve. Curvature is 1/R where R is the instantaneous
      radius of the curve.
      
      * t: number. The point of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: number, The curvature value.
       */
      var d1, d2;
      d1 = this.firstDerivative(t) || 0;
      d2 = this.secondDerivative(t) || 0;
      return (d1.x * d2.y - d1.y * d2.x) / Math.pow(d1.x * d1.x + d1.y * d1.y, 1.5);
    };

    BezierCurve.prototype.tangent = function(t) {

      /*
      Computes the tangent at position t of the curve.
      
      * t: number. The point of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: Point. The tangent as a vector.
       */
      var d, d1;
      d1 = this.firstDerivative(t);
      d = Math.sqrt(d1.x * d1.x + d1.y * d1.y) || 1;
      return new Point(d1.x / d, d1.y / d);
    };

    BezierCurve.prototype.normal = function(t) {

      /*
      Computes the normal at position t of the curve.
      
      * t: number The point of the curve to consider. The curve starts at t=0 and ends at t=1.
      * Returns: Point. The normal as a vector.
       */
      var tan;
      tan = this.tangent(t);
      return new Point(-tan.y, tan.x);
    };

    return BezierCurve;

  })();

  BezierSpline = (function() {

    /*
    A series of BezierCurve's that connect end-to-end, smoothly transitioning from one to the next.
    
    * curves: BezierCurve[]. List of curves that make up the spline
    * startLengths: number[]. The length of the whole spline up to the start of each segment curve
    * endLengths: number[]. The length of the whole spline up to the end of each segment curve
    * length: number. The length of the entire spline
     */
    BezierSpline.computeControlPoints = function(k) {
      var a, b, c, i, j, l, m, n, o, p1, p2, r, ref, ref1, ref2;
      a = function(i) {
        if (i <= 0) {
          return 0;
        } else if (i >= n - 1) {
          return 2;
        } else {
          return 1;
        }
      };
      c = function(i) {
        if (i >= n - 1) {
          return 0;
        } else {
          return 1;
        }
      };
      n = k.length - 1;
      p1 = new Array(n - 1);
      p2 = new Array(n - 1);
      b = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(4);
        }
        return results;
      })();
      b[0] = 2;
      b[n - 1] = 7;
      r = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = n - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(4 * k[i] + 2 * k[i + 1]);
        }
        return results;
      })();
      r[0] = k[0] + 2 * k[1];
      r.push(8 * k[n - 1] + k[n]);
      for (i = j = 0, ref = b.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        m = a(i + 1) / b[i];
        b[i + 1] -= m * c(i);
        r[i + 1] -= m * r[i];
      }
      p1[n - 1] = r[n - 1] / b[n - 1];
      for (i = l = ref1 = b.length - 2; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {
        p1[i] = (r[i] - c(i) * p1[i + 1]) / b[i];
      }
      for (i = o = 0, ref2 = b.length - 1; 0 <= ref2 ? o < ref2 : o > ref2; i = 0 <= ref2 ? ++o : --o) {
        p2[i] = 2 * k[i + 1] - p1[i + 1];
      }
      p2[n - 1] = 0.5 * (k[n] + p1[n - 1]);
      return {
        p1: p1,
        p2: p2
      };
    };

    BezierSpline.computeBezierSpline = function(xs, ys, closed) {
      var c, cx, cy, extend, extendLeft, extendRight, i, j, len, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, ref, ref1, results, startLength;
      extend = 12;
      if (closed) {
        extendRight = function(ns) {
          var i, j, ref, results;
          results = [];
          for (i = j = 0, ref = extend; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(ns[modulo(i, ns.length)]);
          }
          return results;
        };
        extendLeft = function(ns) {
          var i, j, ref, results;
          results = [];
          for (i = j = ref = extend; ref <= 0 ? j < 0 : j > 0; i = ref <= 0 ? ++j : --j) {
            results.push(ns[modulo(ns.length - i, ns.length)]);
          }
          return results;
        };
        xs = slice.call(extendLeft(xs)).concat(slice.call(xs), slice.call(extendRight(xs)));
        ys = slice.call(extendLeft(ys)).concat(slice.call(ys), slice.call(extendRight(ys)));
      }
      cx = BezierSpline.computeControlPoints(xs);
      cy = BezierSpline.computeControlPoints(ys);
      startLength = 0;
      if (closed) {
        xs = xs.slice(extend, +(-extend) + 1 || 9e9);
        ys = ys.slice(extend, +(-extend) + 1 || 9e9);
        cx.p1 = cx.p1.slice(extend, +(-extend) + 1 || 9e9);
        cy.p1 = cy.p1.slice(extend, +(-extend) + 1 || 9e9);
        cx.p2 = cx.p2.slice(extend, +(-extend) + 1 || 9e9);
        cy.p2 = cy.p2.slice(extend, +(-extend) + 1 || 9e9);
      }
      ref = _zip(xs.slice(0, -1), ys.slice(0, -1), cx.p1, cy.p1, cx.p2, cy.p2, xs.slice(1), ys.slice(1));
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        ref1 = ref[i], p0x = ref1[0], p0y = ref1[1], p1x = ref1[2], p1y = ref1[3], p2x = ref1[4], p2y = ref1[5], p3x = ref1[6], p3y = ref1[7];
        c = new BezierCurve(new Point(p0x, p0y), new Point(p1x, p1y), new Point(p2x, p2y), new Point(p3x, p3y));
        c.startLength = startLength;
        c.endLength = startLength + c.length;
        c.segmentOffset = i / (xs.length - 1);
        c.index = i;
        startLength += c.length;
        results.push(c);
      }
      return results;
    };

    function BezierSpline(knots, closed) {

      /*
      
      * knots: Point[]. Array of points that the spline passes through. A curve is generated connecting each knot point to the next.
      * closed: Boolean. Default false. Indicates that the spline should connect its end point back to its start point, making a loop.
       */
      var c;
      this.closed = closed;
      this.curves = BezierSpline.computeBezierSpline(knots.map(function(p) {
        return p.x;
      }), knots.map(function(p) {
        return p.y;
      }), closed);
      this.startLengths = (function() {
        var j, len, ref, results;
        ref = this.curves;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.startLength);
        }
        return results;
      }).call(this);
      this.endLengths = (function() {
        var j, len, ref, results;
        ref = this.curves;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.endLength);
        }
        return results;
      }).call(this);
      this.length = this.endLengths.slice(-1)[0];
    }

    BezierSpline.prototype._curveIndex = function(t) {
      var i;
      i = Math.trunc(t);
      t = t % 1;
      if (i < 0 || i > this.curves.length) {
        return null;
      } else if (i === this.curves.length) {
        return {
          i: i - 1,
          t: t + 1
        };
      } else {
        return {
          i: i,
          t: t
        };
      }
    };

    BezierSpline.prototype.point = function(t) {

      /*
      Computes the point at position t of the curve.
      
      * t The portion of the curve to consider. The spline starts at t=0 and ends at t=curves.length.
      * Returns: Point. the location point.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].point(a.t);
    };

    BezierSpline.prototype.pointAtLength = function(z) {

      /*
      Computes the point at length z of the curve.
      
      * z The length of the curve to travel.
      * Returns: Point. the location point.
       */
      var findCurveIndex, i;
      findCurveIndex = function(lengths, z, start, stop) {
        var mid;
        mid = start + stop >>> 1;
        switch (false) {
          case !(((lengths[mid - 1] || 0) <= z && z <= lengths[mid])):
            return mid;
          case !(z < (lengths[mid - 1] || 0)):
            return findCurveIndex(lengths, z, start, mid);
          default:
            return findCurveIndex(lengths, z, mid + 1, stop);
        }
      };
      i = findCurveIndex(this.endLengths, Math.min(z, this.endLengths[this.endLengths.length - 1]), 0, this.endLengths.length);
      return this.curves[i].pointAtLength(z - this.startLengths[i]);
    };

    BezierSpline.prototype.firstDerivative = function(t) {

      /*
      Computes the first derivative at position t of the curve.
      
      * t The point of the curve to consider. The curve starts at t=0 and ends at t=curves.length.
      * Returns: Point. The derivative as a vector.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].firstDerivative(a.t);
    };

    BezierSpline.prototype.secondDerivative = function(t) {

      /*
      Computes the second derivative at position t of the curve.
      
      * t The point of the curve to consider. The curve starts at t=0 and ends at t=curves.length.
      * Returns: Point. The second derivative as a vector.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].secondDerivative(a.t);
    };

    BezierSpline.prototype.curvature = function(t) {

      /*
      Computes the curvature at position t of the curve. Curvature is 1/R where R is the instantaneous
      radius of the curve.
      
      * t The point of the curve to consider. The curve starts at t=0 and ends at t=curves.length.
      * Returns: number. The curvature value.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].curvature(a.t);
    };

    BezierSpline.prototype.tangent = function(t) {

      /*
      Computes the tangent at position t of the curve.
      
      * t The point of the curve to consider. The curve starts at t=0 and ends at t=curves.length.
      * Returns: Point. The tangent as a vector.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].tangent(a.t);
    };

    BezierSpline.prototype.normal = function(t) {

      /*
      Computes the normal at position t of the curve.
      
      * t The point of the curve to consider. The curve starts at t=0 and ends at t=curves.length.
      * Returns: Point. The normal as a vector.
       */
      var a;
      a = this._curveIndex(t);
      return this.curves[a.i].normal(a.t);
    };

    BezierSpline.prototype.normalize = function(method, segmentLength, segmentCount) {

      /*
      Produces a new BezierSpline with the points normalized.
      
      * method: ('length', 'x'). Default 'length'. Option to indicate if the spline should be recomputed to smooth out numerical
      properties or make drawing easier.
        * length: recompute the spline so that each curve is approximately the same length.
        * x: recompute the curve so that the x values are evenly distributed. Useful for when the knots define a function of y in terms of x coordinates.
      * segmentLength: number. Defatul 1. If normalizing, sets the step interval for how close the normalized knot points should be.
      * segmentCount: number. If normalizing, sets the number of knot points to use, evenly distributed based on the normalization strategy.
       */
      var i, ps;
      segmentCount = segmentCount || Math.ceil(this.length / (segmentLength || 1));
      switch (method) {
        case 'length':
          segmentLength = this.length / segmentCount;
          ps = (function() {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = segmentCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              results.push(this.pointAtLength(i * segmentLength));
            }
            return results;
          }).call(this);
          return new BezierSpline(ps, this.closed);
        case 'x':
          return this;
        default:
          return this;
      }
    };

    return BezierSpline;

  })();

}).call(this);

//# sourceMappingURL=bezier.js.map
